#version 450
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba8) uniform readonly image2D inputImage;

layout(std430, binding = 1) restrict buffer TerminalBuffer {
    uint8_t data[];
} terminalBuffer;

layout(push_constant) uniform Constants {
    uint width;
    uint height;
} push;

// Template: \x1b[38;2;RRR;GGG;BBB;48;2;RRR;GGG;BBBmâ–€
// Length: 39
#define BLOCK_LEN 39
#define HEADER_LEN 12

#define OFF_FG_R 7
#define OFF_BG_R 24

void write_color(uvec3 col, uint base_offset) {
    // Fast integer division by 100: (x * 41943) >> 22
    // 41943 = ceil(2^22 / 100)
    uvec3 d2 = (col * 41943u) >> 22;
    uvec3 rem = col - d2 * 100u;
    
    // Fast integer division by 10: (x * 52429) >> 19
    // 52429 = ceil(2^19 / 10)
    uvec3 d1 = (rem * 52429u) >> 19;
    uvec3 d0 = rem - d1 * 10u;

    // Convert to ASCII
    d2 += 48u;
    d1 += 48u;
    d0 += 48u;

    // Write R (base)
    uint off = base_offset;
    terminalBuffer.data[off]     = uint8_t(d2.x);
    terminalBuffer.data[off + 1] = uint8_t(d1.x);
    terminalBuffer.data[off + 2] = uint8_t(d0.x);

    // Write G (base + 4)
    off += 4;
    terminalBuffer.data[off]     = uint8_t(d2.y);
    terminalBuffer.data[off + 1] = uint8_t(d1.y);
    terminalBuffer.data[off + 2] = uint8_t(d0.y);
    
    // Write B (base + 8)
    off += 4;
    terminalBuffer.data[off]     = uint8_t(d2.z);
    terminalBuffer.data[off + 1] = uint8_t(d1.z);
    terminalBuffer.data[off + 2] = uint8_t(d0.z);
}

void main() {
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;

    // Check bounds. Height is divided by 2 (blocks)
    if (x >= push.width || y >= (push.height + 1) >> 1) {
        return;
    }

    // Load pixels for upper and lower half of the block
    // Use vectorized operations for 3 channels at once
    uvec3 fg = uvec3(imageLoad(inputImage, ivec2(x, y << 1)).rgb * 255.0 + 0.5);
    uvec3 bg = uvec3(imageLoad(inputImage, ivec2(x, (y << 1) + 1)).rgb * 255.0 + 0.5);

    uint block_idx = (y * push.width + x);
    uint base_offset = HEADER_LEN + block_idx * BLOCK_LEN;

    write_color(fg, base_offset + OFF_FG_R);
    write_color(bg, base_offset + OFF_BG_R);
}
